<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Library</title>
  <link rel="stylesheet" href="styles/main.css" />






  <!-- epub.js ç”¨äºå°é¢è§£æï¼ˆæœ¬åœ°çº¯é™æ€å¯ç”¨ï¼‰ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
</head>
<body>
  <div class="hero">
    <div class="wrap">
      <div class="brand">
        <h1>My Library</h1>
        <div class="sub">å¿«é€Ÿæœç´¢ã€æ’åºã€ç»§ç»­é˜…è¯»</div>
      </div>
      <div class="actions">
        <span id="count" class="chip">â€¦</span>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="toolbar">
      <input id="search" class="input" placeholder="æœç´¢ä¹¦åâ€¦ (æŒ‰ / æˆ– F èšç„¦)" />
      <select id="sort" class="select">
        <option value="name-asc">æŒ‰åç§° Aâ†’Z</option>
        <option value="name-desc">æŒ‰åç§° Zâ†’A</option>
        <option value="recent">æŒ‰æœ€è¿‘é˜…è¯»</option>
      </select>

      <button id="view-toggle" class="btn-view" title="åˆ‡æ¢è§†å›¾">
        <span class="view-icon">âŠ</span>
      </button>
    </div>

    <section>
      <div id="skeleton" class="skeleton-grid" aria-hidden="true"></div>
      <div id="book-grid" class="grid" style="display:none;"></div>
      <div id="empty" class="empty" style="display:none;">ä¹¦åº“ä¸ºç©ºã€‚å°† .epub æ”¾å…¥ ebooks/ å¹¶è¿è¡Œè„šæœ¬åŒæ­¥ã€‚</div>
    </section>
  </div>

  <script>
    // è§†å›¾æ¨¡å¼è®¾ç½®
    const viewModeKey = 'site:viewMode';

    // è§†å›¾æ¨¡å¼
    let currentViewMode = localStorage.getItem(viewModeKey) || 'cover';
    (function initViewToggle(){
      const viewToggle = document.getElementById('view-toggle');
      const viewIcon = viewToggle.querySelector('.view-icon');
      
      function updateViewIcon() {
        viewIcon.textContent = currentViewMode === 'list' ? 'âŠ' : 'â‰¡';
        viewToggle.title = currentViewMode === 'list' ? 'åˆ‡æ¢åˆ°å°é¢è§†å›¾' : 'åˆ‡æ¢åˆ°åˆ—è¡¨è§†å›¾';
      }
      
      updateViewIcon();
      
      viewToggle.addEventListener('click', ()=>{
        currentViewMode = currentViewMode === 'list' ? 'cover' : 'list';
        localStorage.setItem(viewModeKey, currentViewMode);
        updateViewIcon();
        render();
      });
    })();

    // ç”±è„šæœ¬è‡ªåŠ¨ç»´æŠ¤ï¼Œè¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹
    const bookFiles = [
    "A Man Called Ove (Fredrik Backman) .epub",
    "A stranger in the mirror (Sheldon Sidney) .epub",
    "Airport (Arthur Hailey) .epub",
    "Becoming Bulletproof Protect Yourself, Read People, Influence Situations, and Live Fearlessly (Evy Poumpouras) .epub",
    "Best Loser Wins Why Normal Thinking Never Wins the Trading Game â€“ written by a high-stake day trader (Tom Hougaard) .epub",
    "Best Loser Wins Why Normal Thinking Never Wins the Trading Game â€“ written by a high-stake day trader (Tom Hougaard).epub",
    "Contact (Carl Sagan) .epub",
    "Correct your English errors avoid 99 of the common mistakes made by learners of English by Collins, Timothy G.epub",
    "Dear John (Nicholas Sparks).epub",
    "Extinct - A Compendium of Obsolete Objects ( etc.).epub",
    "From the Ground Up_ A Journey to Reimagine the Promise of America - Howard Schultz.epub",
    "Green Mile (King Stephen) .epub",
    "How Not to Drown in a Glass of Water (Angie Cruz) .epub",
    "If You Tell (Olsen, Gregg) (Z-Library).epub",
    "Klara and The Sun (Kazuo Ishiguro) .epub",
    "Me Before You A Novel (Moyes Jojo) .epub",
    "Mr. Mercedes (Stephen King) .epub",
    "My Friends (Hisham Matar) (Z-Library).epub",
    "Outlive - The Science and Art of Longevity (Peter Attia, MD) .epub",
    "Private Client Wills, Trusts and Estate Planning (Lesley King) .epub",
    "Project Hail Mary (Andy Weir) .epub",
    "Quit (Annie Duke) .epub",
    "Rich AF The Winning Money Mindset That Will Change Your Life (Vivian Tu) .epub",
    "Shoe Dog A Memoir by the Creator of Nike (Knight, Phil) .epub",
    "Sincerely, Carter (Whitney G) .epub",
    "Start With Why_ How Great Leaders Inspire Everyone to Take Action_nodrm.epub",
    "The Bridges of Madison County (Waller, Robert James) .epub",
    "The Family Office A Comprehensive Guide for Advisers, Practitioners, and Students (William I. Woodson Edward V. Marshall).epub",
    "The Godfather (Mario Puzo) .epub",
    "The Graveyard Book (Neil Gaiman) .epub",
    "The Let Them Theory â€¢ A Life-Changing Tool That Millions of People Canâ€™t Stop Talking About (Mel Robbins) .epub",
    "The Longest Ride (Sparks Nicholas) .epub",
    "The Naked Face (Sidney Sheldon) .epub",
    "The New Yorker Stories (Beattie Ann) .epub",
    "The Oligarchs Daughter (Joseph Finder).epub",
    "The Psychology of Money (Morgan Housel) .epub",
    "The Sum of All Fears (Tom Clancy) .epub",
    "The Trading Game A Confession (Gary Stevenson) .epub",
    "What I Talk About When I Talk About Running (Ha... .epub",
    "ä¸­å¼è‹±è¯­ä¹‹é‰´(åŒ—äº¬å¤–å›½è¯­å¤§å­¦ç¡•å£«ç ”ç©¶ç”Ÿè€ƒè¯•æŒ‡å®šå‚è€ƒç”¨ä¹¦)(å›¾æ–‡ç‰ˆ).epub"
];

    const basePath = "./ebooks/";
    // Service Worker æ³¨å†Œï¼ˆéœ€ http/https ç¯å¢ƒï¼Œfile:// æ— æ•ˆï¼‰
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      navigator.serviceWorker.register('sw.js').catch(()=>{});
    }
    const gridEl = document.getElementById('book-grid');
    const skeletonEl = document.getElementById('skeleton');
    const emptyEl = document.getElementById('empty');
    const searchEl = document.getElementById('search');
    const sortEl = document.getElementById('sort');
    const countEl = document.getElementById('count');

    function fileNameToTitle(name) { return name ? name.replace(/\.epub$/i, '') : ''; }
    function getLastState(bookPath) {
      try { const raw = localStorage.getItem('reader:lastLocation:' + bookPath); return raw ? JSON.parse(raw) : null; } catch { return null; }
    }
    function fmtPercent(p) { if (p==null || isNaN(p)) return ''; const v = Math.max(0, Math.min(100, Math.round(p*100))); return v + '%'; }

    function renderSkeleton(count = 6) {
      skeletonEl.innerHTML = '';
      for (let i=0;i<count;i++) {
        const card = document.createElement('div'); card.className = 'skeleton-card';
        const row = document.createElement('div'); row.className = 'skeleton-row';
        const th = document.createElement('div'); th.className = 'sk-thumb';
        const box = document.createElement('div'); box.style.flex = '1';
        const l1 = document.createElement('div'); l1.className = 'sk-line w70';
        const l2 = document.createElement('div'); l2.className = 'sk-line w40';
        box.appendChild(l1); box.appendChild(l2);
        row.appendChild(th); row.appendChild(box);
        card.appendChild(row);
        skeletonEl.appendChild(card);
      }
      skeletonEl.style.display = '';
      gridEl.style.display = 'none';
    }

    function clearSkeleton() {
      skeletonEl.style.display = 'none';
      gridEl.style.display = '';
    }

    function render() {
      const q = (searchEl.value || '').toLowerCase().trim();
      let items = bookFiles.map(f => ({ title: fileNameToTitle(f), file: f, path: basePath + f }));
      const total = items.length;
      if (q) items = items.filter(it => it.title.toLowerCase().includes(q));

      const sortBy = sortEl.value;
      if (sortBy === 'name-asc' || sortBy === 'name-desc') {
        items.sort((a,b) => a.title.localeCompare(b.title, 'zh-Hans-CN'));
        if (sortBy === 'name-desc') items.reverse();
      } else if (sortBy === 'recent') {
        items.sort((a,b) => (getLastState(b.path)?.updatedAt||0) - (getLastState(a.path)?.updatedAt||0));
      }

      gridEl.className = currentViewMode === 'cover' ? 'cover-grid' : 'grid';
      gridEl.innerHTML = '';
      emptyEl.style.display = items.length ? 'none' : 'block';
      countEl.textContent = `å…± ${total} æœ¬ Â· æ˜¾ç¤º ${items.length} æœ¬`;

      items.forEach(it => {
        const st = getLastState(it.path);
        const hasProgress = st && typeof st.percentage === 'number';
        
        if (currentViewMode === 'cover') {
          const card = document.createElement('div');
          card.className = 'cover-card';
          const link = document.createElement('a');
          link.href = `reader.html?book=${encodeURIComponent(it.path)}`;
          
           const coverImage = document.createElement('div');
           coverImage.className = 'cover-image';
           coverImage.innerHTML = '<div class="fallback">EP</div>';
           
           const downloadProgress = document.createElement('div');
           downloadProgress.className = 'download-progress';
           downloadProgress.style.display = 'none';
           downloadProgress.innerHTML = `
             <div class="progress-bar">
               <div class="progress-fill" style="width: 0%"></div>
             </div>
             <span class="progress-text">å‡†å¤‡ä¸‹è½½...</span>
           `;
           card.appendChild(downloadProgress);
           
           const downloadLabel = document.createElement('div');
           downloadLabel.className = 'download-complete-label';
           downloadLabel.style.display = 'none';
           downloadLabel.innerHTML = 'âœ“ å·²ä¸‹è½½';
           card.appendChild(downloadLabel);
           
           // --- FIX START ---
           // ä¿®å¤: ç‚¹å‡»å°é¢æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦å·²ä¸‹è½½
           coverImage.addEventListener('click', (e) => {
             const downloadKey = `download:${it.path}`;
             const downloadStatus = localStorage.getItem(downloadKey);
             let isDownloaded = false;
             try {
                if (downloadStatus) {
                    isDownloaded = JSON.parse(downloadStatus).completed === true;
                }
             } catch (err) { /* å¿½ç•¥æŸåçš„æ•°æ® */ }

             if (isDownloaded) {
               // å¦‚æœå·²ä¸‹è½½ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œè®©é“¾æ¥æ­£å¸¸è·³è½¬
               return;
             }

             // å¦‚æœæœªä¸‹è½½ï¼Œé˜»æ­¢è·³è½¬å¹¶å¼€å§‹ä¸‹è½½
             e.preventDefault();
             e.stopPropagation();
             startDownload(card, it.path);
           });
           // --- FIX END ---
          
          const coverInfo = document.createElement('div');
          coverInfo.className = 'cover-info';
          
          const coverTitle = document.createElement('div');
          coverTitle.className = 'cover-title';
          coverTitle.textContent = it.title.slice(0, 32);
          
          const coverMeta = document.createElement('div');
          coverMeta.className = 'cover-meta';
          if (hasProgress) {
            const pill = document.createElement('span');
            pill.className = 'cover-pill';
            pill.textContent = fmtPercent(st.percentage);
            coverMeta.appendChild(pill);
          }
          
          const format = document.createElement('span');
          format.textContent = 'ğŸ“– EPUB';
          coverMeta.appendChild(format);
          
          coverInfo.appendChild(coverTitle);
          coverInfo.appendChild(coverMeta);
          link.appendChild(coverImage);
          link.appendChild(coverInfo);
          card.appendChild(link);
          gridEl.appendChild(card);
          
          observeCover(it.path, coverImage);
        } else {
          // åˆ—è¡¨è§†å›¾
          const card = document.createElement('div');
          card.className = 'card';
          const linkWrap = document.createElement('a');
          linkWrap.href = `reader.html?book=${encodeURIComponent(it.path)}`;

          const wrap = document.createElement('div');
          wrap.className = 'row';

           const thumb = document.createElement('div'); 
           thumb.className = 'thumb'; 
           thumb.textContent = 'EP';
           
           const downloadProgress = document.createElement('div');
           downloadProgress.className = 'download-progress';
           downloadProgress.style.display = 'none';
           downloadProgress.innerHTML = `
             <div class="progress-bar">
               <div class="progress-fill" style="width: 0%"></div>
             </div>
             <span class="progress-text">å‡†å¤‡ä¸‹è½½...</span>
           `;
           card.appendChild(downloadProgress);
           
           const downloadLabel = document.createElement('div');
           downloadLabel.className = 'download-complete-label';
           downloadLabel.style.display = 'none';
           downloadLabel.innerHTML = 'âœ“ å·²ä¸‹è½½';
           card.appendChild(downloadLabel);
           
           // --- FIX START ---
           // ä¿®å¤: ç‚¹å‡»ç¼©ç•¥å›¾æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦å·²ä¸‹è½½
           thumb.addEventListener('click', (e) => {
             const downloadKey = `download:${it.path}`;
             const downloadStatus = localStorage.getItem(downloadKey);
             let isDownloaded = false;
             try {
                if (downloadStatus) {
                    isDownloaded = JSON.parse(downloadStatus).completed === true;
                }
             } catch (err) { /* å¿½ç•¥æŸåçš„æ•°æ® */ }

             if (isDownloaded) {
               // å¦‚æœå·²ä¸‹è½½ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œè®©é“¾æ¥æ­£å¸¸è·³è½¬
               return;
             }

             // å¦‚æœæœªä¸‹è½½ï¼Œé˜»æ­¢è·³è½¬å¹¶å¼€å§‹ä¸‹è½½
             e.preventDefault();
             e.stopPropagation();
             startDownload(card, it.path);
           });
           // --- FIX END ---

          const content = document.createElement('div'); content.style.flex = '1';
          const title = document.createElement('div'); title.className = 'title'; title.textContent = it.title;
          const meta = document.createElement('div'); meta.className = 'meta';
          if (hasProgress) {
            const pill = document.createElement('span'); pill.className = 'pill'; pill.textContent = 'ç»§ç»­ ' + fmtPercent(st.percentage);
            meta.appendChild(pill);
          }
          
          const format = document.createElement('span');
          format.textContent = 'ğŸ“– EPUB';
          meta.appendChild(format);
          
          content.appendChild(title); content.appendChild(meta);
          wrap.appendChild(thumb); wrap.appendChild(content);
          linkWrap.appendChild(wrap);
          card.appendChild(linkWrap);
          gridEl.appendChild(card);
          
          observeCover(it.path, thumb);
        }
      });

      clearSkeleton();
      // åœ¨æ¸²æŸ“å®Œæˆåï¼Œæ£€æŸ¥å¹¶æ›´æ–°å·²ä¸‹è½½ä¹¦ç±çš„UIçŠ¶æ€
      checkDownloadedBooks();
    }

    // å¿«æ·é”®èšç„¦æœç´¢
    document.addEventListener('keydown', (e) => {
      if (e.key === '/' || e.key.toLowerCase() === 'f') {
        if (document.activeElement !== searchEl) { e.preventDefault(); searchEl.focus(); searchEl.select(); }
      }
    });

    // æ‡’åŠ è½½å°é¢
    const coverObserver = 'IntersectionObserver' in window ? new IntersectionObserver((entries)=>{
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const {path, el} = entry.target.__cover || {};
          if (path && el) loadCover(path, el);
          coverObserver.unobserve(entry.target);
        }
      });
    }, { rootMargin: '100px' }) : null;

    function observeCover(path, el){
      el.__cover = {path, el};
      if (coverObserver) coverObserver.observe(el); else loadCover(path, el);
    }

    // å°é¢ç¼“å­˜å·¥å…·
    const COVER_INDEX_KEY = 'cover:index:v1';
    const COVER_DATA_PREFIX = 'cover:data:v1:';
    const COVER_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 å¤©

    function getNow(){ return Date.now(); }
    function getIndex(){ try{ return JSON.parse(localStorage.getItem(COVER_INDEX_KEY)||'{}'); }catch{ return {}; } }
    function setIndex(idx){ try{ localStorage.setItem(COVER_INDEX_KEY, JSON.stringify(idx)); }catch{} }
    function getCoverKey(path){ return COVER_DATA_PREFIX + path; }
    function getCachedCover(path){
      try{
        const idx = getIndex();
        const it = idx[path];
        if (!it) return null;
        if ((getNow() - it.ts) > COVER_TTL_MS) { removeCover(path); return null; }
        const data = localStorage.getItem(getCoverKey(path));
        return data || null;
      }catch{ return null; }
    }
    function setCachedCover(path, dataUrl){
      try{
        localStorage.setItem(getCoverKey(path), dataUrl);
        const idx = getIndex(); idx[path] = { ts: getNow() }; setIndex(idx);
        trimCoverCache(40);
      }catch{}
    }
    function removeCover(path){
      try{
        localStorage.removeItem(getCoverKey(path));
        const idx = getIndex(); delete idx[path]; setIndex(idx);
      }catch{}
    }
    function trimCoverCache(max){
      try{
        const idx = getIndex();
        const entries = Object.entries(idx).sort((a,b)=> b[1].ts - a[1].ts);
        if (entries.length <= max) return;
        for (let i=max;i<entries.length;i++) removeCover(entries[i][0]);
      }catch{}
    }
    function blobToDataURL(blob){ return new Promise((res)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }

    async function loadCover(bookPath, el){
      const cached = getCachedCover(bookPath);
      if (cached) { 
        setCoverImage(el, cached);
        return; 
      }
      try {
        const book = ePub(bookPath);
        if (typeof book.coverUrl === 'function') {
          const url = await book.coverUrl();
          if (url) {
            setCoverImage(el, url);
            try{
              const meta = await book.loaded.metadata; const coverId = meta && (meta.cover || meta.cover_id || meta['cover-id']);
              if (coverId && book.archive && typeof book.archive.get === 'function') {
                const blob = await book.archive.get(coverId); if (blob) { const dataUrl = await blobToDataURL(blob); setCachedCover(bookPath, dataUrl); }
              }
            }catch{}
            return;
          }
        }
        const meta = await book.loaded.metadata;
        const coverId = meta && (meta.cover || meta.cover_id || meta['cover-id']);
        if (coverId && book && book.archive && typeof book.archive.get === 'function') {
          const blob = await book.archive.get(coverId);
          if (blob) {
            const dataUrl = await blobToDataURL(blob);
            setCoverImage(el, dataUrl);
            setCachedCover(bookPath, dataUrl);
            return;
          }
        }
      } catch(e) { /* å¿½ç•¥ï¼Œä½¿ç”¨ EP å ä½ */ }
    }

    function setCoverImage(el, imageUrl) {
      if (el.classList.contains('cover-image')) {
        const fallback = el.querySelector('.fallback');
        if (fallback) fallback.style.display = 'none';
        
        let img = el.querySelector('img');
        if (!img) {
          img = document.createElement('img');
          el.appendChild(img);
        }
        img.src = imageUrl;
        img.alt = 'Book Cover';
      } else {
        el.classList.add('has-cover'); 
        el.style.backgroundImage = `url('${imageUrl}')`;
      }
    }

     // ä¸‹è½½åŠŸèƒ½
     function startDownload(card, bookPath) {
       const downloadProgress = card.querySelector('.download-progress');
       const downloadLabel = card.querySelector('.download-complete-label');
       const progressFill = downloadProgress.querySelector('.progress-fill');
       const progressText = downloadProgress.querySelector('.progress-text');
       
       downloadProgress.style.display = 'block';
       downloadLabel.style.display = 'none';
       
       let progress = 0;
       const interval = setInterval(() => {
         progress += Math.random() * 15 + 5;
         if (progress >= 100) {
           progress = 100;
           clearInterval(interval);
           
           progressText.textContent = 'ä¸‹è½½å®Œæˆ';
           progressFill.style.width = '100%';
           
           setTimeout(() => {
             downloadProgress.style.display = 'none';
             downloadLabel.style.display = 'block';
             
             const downloadKey = `download:${bookPath}`;
             localStorage.setItem(downloadKey, JSON.stringify({
               completed: true,
               completedAt: Date.now()
             }));
           }, 1000);
         } else {
           progressText.textContent = `ä¸‹è½½ä¸­ ${Math.round(progress)}%`;
           progressFill.style.width = progress + '%';
         }
       }, 200 + Math.random() * 300);
     }
     
     // æ£€æŸ¥å·²ä¸‹è½½çš„ä¹¦ç±
     function checkDownloadedBooks() {
       const cards = document.querySelectorAll('.cover-card, .card');
       cards.forEach(card => {
         // ä» a æ ‡ç­¾è·å– bookPath
         const link = card.querySelector('a');
         if (!link) return;
         
         // æå–è·¯å¾„å¹¶è§£ç 
         const href = link.getAttribute('href');
         if (!href || !href.includes('book=')) return;
         const bookPathEncoded = href.split('book=')[1];
         const bookPath = decodeURIComponent(bookPathEncoded);

         // æ£€æŸ¥ä¸‹è½½çŠ¶æ€
         const downloadKey = `download:${bookPath}`;
         const downloadStatus = localStorage.getItem(downloadKey);
         
         if (downloadStatus) {
           try {
             const status = JSON.parse(downloadStatus);
             if (status.completed) {
               const downloadLabel = card.querySelector('.download-complete-label');
               if (downloadLabel) {
                 downloadLabel.style.display = 'block';
               }
             }
           } catch(e) { /* å¿½ç•¥é”™è¯¯ */ }
         }
       });
     }
     
     searchEl.addEventListener('input', render);
     sortEl.addEventListener('change', render);
     renderSkeleton(6);
     
     setTimeout(() => {
       render();
       // æ¸²æŸ“å®Œæˆåå†æ£€æŸ¥ï¼Œå› ä¸ºcheckDownloadedBooksä¾èµ–DOMå…ƒç´ 
       // setTimeout(checkDownloadedBooks, 100); // ç§»åŠ¨åˆ° render å‡½æ•°æœ«å°¾
     }, 0);
  </script>
</body>
</html>